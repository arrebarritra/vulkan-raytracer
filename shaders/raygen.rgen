#version 460
#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_scalar_block_layout : require
#extension GL_EXT_debug_printf : enable

#include "constants.glsl"
#include "payload.glsl"
#include "random.glsl"
#include "hdr.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 1, set = 0, rgba8) uniform image2D accumulationImage;
layout(binding = 2, set = 0, rgba8) uniform image2D outputImage;
layout(binding = 3, set = 0, scalar) uniform CameraProperties {
    mat4 viewInverse, projInverse;
} cam;

layout(binding = 4, set = 0, scalar) uniform PathTracingProperties{
    uint sampleCount, maxRayDepth;
} pathTracing;

layout(location = 0) rayPayloadEXT PathTracingPayload payload;

void main() {
    uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchIDEXT.x + gl_LaunchIDEXT.x, pathTracing.sampleCount);
    vec2 jitter = vec2(rnd(seed), rnd(seed));

    const vec2 pixelCenter = vec2(gl_LaunchIDEXT.xy) + jitter;
    const vec2 inUV = pixelCenter / vec2(gl_LaunchSizeEXT.xy);
    vec2 d = inUV * 2.0 - 1.0;
    d.y = -d.y;

    payload.rayOrigin = vec3(cam.viewInverse * vec4(0,0,0,1));
    vec3 target = vec3(cam.projInverse * vec4(d.x, d.y, 1, 1));
    vec3 direction = vec3(cam.viewInverse * vec4(normalize(target.xyz), 0));

    float tmin = 0.001;
    float tmax = 1000.0;

    vec3 value = vec3(0.0);
    vec3 currentPath = vec3(1.0);
    int i = 0;
    uint rayFlags = gl_RayFlagsNoneEXT;
    for (int i = 0; true; i++) {
        traceRayEXT(topLevelAS, rayFlags, 0xFF, 0, 0, 0, payload.rayOrigin, tmin, direction, tmax, 0);

        value += currentPath * payload.emittedLight;
        if (payload.emittedLight != vec3(0.0) || payload.hitNormal == vec3(-1.0) || i == pathTracing.maxRayDepth - 1)
            break;

        value += currentPath *  payload.baseColour * payload.directLight;
        if (pathTracing.sampleCount == 0u) {
            value += 0.5 * payload.baseColour;
            break;
        }

        bool transmitted = rnd(seed) < payload.transmissionFactor;
        if (!transmitted)
            direction = sampleCosineHemisphere(payload.hitNormal, seed);
        payload.rayOrigin = payload.hitPos + BIAS * (transmitted ? -1.0 : 1.0) * payload.hitNormal;

        currentPath *= payload.baseColour * PI;
    }


    if (pathTracing.sampleCount > 0u) {
        vec3 prevValue = imageLoad(accumulationImage, ivec2(gl_LaunchIDEXT.xy)).xyz;
        vec3 accumulatedValue = prevValue + value;
        imageStore(accumulationImage, ivec2(gl_LaunchIDEXT.xy), vec4(accumulatedValue, 1.0));

        vec3 normalisedValue = accumulatedValue / pathTracing.sampleCount;
        imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(reinhardJodie(normalisedValue), 1.0));
    } else {
        imageStore(accumulationImage, ivec2(gl_LaunchIDEXT.xy), vec4(0.0));
        imageStore(outputImage, ivec2(gl_LaunchIDEXT.xy), vec4(reinhardJodie(value), 1.0));
    }
}