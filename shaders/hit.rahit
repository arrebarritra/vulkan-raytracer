#version 460

#extension GL_EXT_ray_tracing : enable
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_debug_printf : enable
#extension GL_EXT_shader_explicit_arithmetic_types_int32 : require
#extension GL_EXT_shader_explicit_arithmetic_types_int64 : require
#extension GL_EXT_buffer_reference : require
#extension GL_EXT_scalar_block_layout : require

#include "geometry.glsl"
#include "material.glsl"
#include "texture.glsl"
#include "random.glsl"

layout(binding = 0, set = 0) uniform accelerationStructureEXT topLevelAS;
layout(binding = 4, set = 0, scalar) uniform PathTracingProperties{
    uint sampleCount, maxRayDepth;
} pathTracing;

hitAttributeEXT vec2 attribs;

float unpackTriangle(uint idx, vec3 weights, out Material material) {
    GeometryInfo geometryInfo = geometryInfos[gl_InstanceCustomIndexEXT];
    material = materials[geometryInfo.materialIdx];
    Indices indexBuffer = Indices(geometryInfo.indexBufferAddress);
    Vertices vertexBuffer = Vertices(geometryInfo.vertexBufferAddress);
    
    vec2 uv0 = vec2(0.0);
    for (int i = 0; i < 3; i++) {
        uint index = indexBuffer.indices[3 * idx + i];
        Vertex vertex = vertexBuffer.vertices[index];
        uv0 += vertex.uv0 * weights[i];
    }

    float alpha = material.baseColourFactor.a;
    if (material.baseColourTexIdx != -1)
        alpha *= textureGet(material.baseColourTexIdx, uv0).a;
    return alpha;
}

void main() {
    uint seed = tea(gl_PrimitiveID * gl_LaunchIDEXT.y * gl_LaunchIDEXT.x + gl_LaunchIDEXT.y * gl_LaunchIDEXT.x + gl_LaunchIDEXT.x, pathTracing.sampleCount);

    const vec3 barycentricCoords = vec3(1.0f - attribs.x - attribs.y, attribs.x, attribs.y);
    Material mat;
    float alpha = unpackTriangle(gl_PrimitiveID, barycentricCoords, mat);
    
    if ((mat.alphaMode == 1 && alpha < mat.alphaCutoff) || (mat.alphaMode == 2 && rnd(seed) < (1 - alpha))) {
        ignoreIntersectionEXT;
    }
}